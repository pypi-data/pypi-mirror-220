from typing import Mapping
from typing import Sequence
from typing import Union

from _typeshed import Incomplete
import ase
from ase.utils.arraywrapper import arraylike as arraylike
import numpy as np
import numpy.typing as npt

@arraylike
class Cell:
    ase_objtype: str
    array: Incomplete
    def __init__(self, array) -> None: ...
    def cellpar(self, radians: bool = ...): ...
    def todict(self): ...
    @classmethod
    def ascell(cls, cell): ...
    @classmethod
    def new(cls, cell: npt.ArrayLike[float] | npt.ArrayLike[npt.ArrayLike[float]] | None = ...): ...
    @classmethod
    def fromcellpar(cls, cellpar, ab_normal=..., a_direction: Incomplete | None = ...): ...
    def get_bravais_lattice(self, eps: float = ..., *, pbc: bool = ...): ...
    def bandpath(self, path: str = ..., npoints: int = ..., *, density: float = ..., special_points: Mapping[str, Sequence[float]] = ..., eps: float = ..., pbc: Union[bool, Sequence[bool]] = ...) -> ase.dft.kpoints.BandPath: ...
    def uncomplete(self, pbc): ...
    def complete(self): ...
    def copy(self): ...
    @property
    def rank(self) -> int: ...
    @property
    def orthorhombic(self) -> bool: ...
    def lengths(self): ...
    def angles(self): ...
    def __array__(self, dtype=...): ...
    def __bool__(self) -> bool: ...
    __nonzero__ = __bool__
    @property
    def volume(self) -> float: ...
    @property
    def handedness(self) -> int: ...
    def scaled_positions(self, positions) -> np.ndarray: ...
    def cartesian_positions(self, scaled_positions) -> np.ndarray: ...
    def reciprocal(self) -> Cell: ...
    def niggli_reduce(self, eps: float = ...): ...
    def minkowski_reduce(self): ...
    def permute_axes(self, permutation): ...
    def standard_form(self): ...
