{
  "version": 3,
  "sources": ["../../../node_modules/idiomorph/dist/idiomorph.js", "../../../node_modules/reconnecting-websocket/dist/reconnecting-websocket-mjs.js", "reactor-boost.js", "reactor.js"],
  "sourcesContent": ["//=============================================================================\n// AMD insanity... i hate javascript so much\n//\n// IGNORE EVERYTHING FROM HERE UNTIL THE COMMENT SAYING 'AND NOW IT BEGINS...\"\n//=============================================================================\n(function (root, factory) {\n    //@ts-ignore\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        //@ts-ignore\n        define([], factory);\n    } else {\n        // Browser globals\n        root.Idiomorph = root.Idiomorph || factory();\n    }\n}(typeof self !== 'undefined' ? self : this,\n    function () {\n        return (function () {\n            'use strict';\n\n            //=============================================================================\n            // AND NOW IT BEGINS...\n            //=============================================================================\n            let EMPTY_SET = new Set();\n\n            //=============================================================================\n            // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n            //=============================================================================\n            function morph(oldNode, newContent, config = {}) {\n\n                if (oldNode instanceof Document) {\n                    oldNode = oldNode.documentElement;\n                }\n\n                if (typeof newContent === 'string') {\n                    newContent = parseContent(newContent);\n                }\n\n                let normalizedContent = normalizeContent(newContent);\n\n                let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n                return morphNormalizedContent(oldNode, normalizedContent, ctx);\n            }\n\n            function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n                if (ctx.head.block) {\n                    let oldHead = oldNode.querySelector('head');\n                    let newHead = normalizedNewContent.querySelector('head');\n                    if (oldHead && newHead) {\n                        let promises = handleHeadElement(newHead, oldHead, ctx);\n                        // when head promises resolve, call morph again, ignoring the head tag\n                        Promise.all(promises).then(function () {\n                            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                                head: {\n                                    block: false,\n                                    ignore: true\n                                }\n                            }));\n                        });\n                        return;\n                    }\n                }\n\n                if (ctx.morphStyle === \"innerHTML\") {\n\n                    // innerHTML, so we are only updating the children\n                    morphChildren(normalizedNewContent, oldNode, ctx);\n                    return oldNode.children;\n\n                } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                    // otherwise find the best element match in the new content, morph that, and merge its siblings\n                    // into either side of the best match\n                    let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                    // stash the siblings that will need to be inserted on either side of the best match\n                    let previousSibling = bestMatch?.previousSibling;\n                    let nextSibling = bestMatch?.nextSibling;\n\n                    // morph it\n                    let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                    if (bestMatch) {\n                        // if there was a best match, merge the siblings in too and return the\n                        // whole bunch\n                        return insertSiblings(previousSibling, morphedNode, nextSibling);\n                    } else {\n                        // otherwise nothing was added to the DOM\n                        return []\n                    }\n                } else {\n                    throw \"Do not understand how to morph style \" + ctx.morphStyle;\n                }\n            }\n\n\n\n            /**\n             * @param oldNode root node to merge content into\n             * @param newContent new content to merge\n             * @param ctx the merge context\n             * @returns {Element} the element that ended up in the DOM\n             */\n            function morphOldNodeTo(oldNode, newContent, ctx) {\n                if (ctx.ignoreActive && oldNode === document.activeElement) {\n                    // don't morph focused element\n                } else if (newContent == null) {\n                    ctx.callbacks.beforeNodeRemoved(oldNode);\n                    oldNode.remove();\n                    ctx.callbacks.afterNodeRemoved(oldNode);\n                    return null;\n                } else if (!isSoftMatch(oldNode, newContent)) {\n                    ctx.callbacks.beforeNodeRemoved(oldNode);\n                    ctx.callbacks.beforeNodeAdded(newContent);\n                    oldNode.parentElement.replaceChild(newContent, oldNode);\n                    ctx.callbacks.afterNodeAdded(newContent);\n                    ctx.callbacks.afterNodeRemoved(oldNode);\n                    return newContent;\n                } else {\n                    ctx.callbacks.beforeNodeMorphed(oldNode, newContent);\n                    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                        // ignore the head element\n                    } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                        handleHeadElement(newContent, oldNode, ctx);\n                    } else {\n                        syncNodeFrom(newContent, oldNode);\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                    ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                    return oldNode;\n                }\n            }\n\n            /**\n             * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n             * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n             * by using id sets, we are able to better match up with content deeper in the DOM.\n             *\n             * Basic algorithm is, for each node in the new content:\n             *\n             * - if we have reached the end of the old parent, append the new content\n             * - if the new content has an id set match with the current insertion point, morph\n             * - search for an id set match\n             * - if id set match found, morph\n             * - otherwise search for a \"soft\" match\n             * - if a soft match is found, morph\n             * - otherwise, prepend the new node before the current insertion point\n             *\n             * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n             * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n             *\n             * @param {Element} newParent the parent element of the new content\n             * @param {Element } oldParent the old content that we are merging the new content into\n             * @param ctx the merge context\n             */\n            function morphChildren(newParent, oldParent, ctx) {\n\n                let nextNewChild = newParent.firstChild;\n                let insertionPoint = oldParent.firstChild;\n\n                // run through all the new content\n                while (nextNewChild) {\n\n                    let newChild = nextNewChild;\n                    nextNewChild = newChild.nextSibling;\n\n                    // if we are at the end of the exiting parent's children, just append\n                    if (insertionPoint == null) {\n\n                        ctx.callbacks.beforeNodeAdded(newChild);\n                        oldParent.appendChild(newChild);\n                        ctx.callbacks.afterNodeAdded(newChild);\n\n                        // if the current node has an id set match then morph\n                    } else if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n\n                        morphOldNodeTo(insertionPoint, newChild, ctx);\n                        insertionPoint = insertionPoint.nextSibling;\n\n                    } else {\n\n                        // otherwise search forward in the existing old children for an id set match\n                        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                        // if we found a potential match, remove the nodes until that point and morph\n                        if (idSetMatch) {\n\n                            insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                            morphOldNodeTo(idSetMatch, newChild, ctx);\n\n                        } else {\n\n                            // no id set match found, so scan forward for a soft match for the current node\n                            let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                            // if we found a soft match for the current node, morph\n                            if (softMatch) {\n\n                                insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                                morphOldNodeTo(softMatch, newChild, ctx);\n\n                            } else {\n\n                                // abandon all hope of morphing, just insert the new child before the insertion point\n                                // and move on\n                                ctx.callbacks.beforeNodeAdded(newChild);\n                                oldParent.insertBefore(newChild, insertionPoint);\n                                ctx.callbacks.afterNodeAdded(newChild);\n\n                            }\n                        }\n                    }\n\n                    // remove the processed new contents ids from consideration in future merge decisions\n                    removeIdsFromConsideration(ctx, newChild);\n                }\n\n                // remove any remaining old nodes that didn't match up with new content\n                while (insertionPoint !== null) {\n\n                    let tempNode = insertionPoint;\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeNode(tempNode, ctx);\n                }\n            }\n\n            //=============================================================================\n            // Attribute Syncing Code\n            //=============================================================================\n\n            /**\n             * syncs a given node with another node, copying over all attributes and\n             * inner element state from the 'from' node to the 'to' node\n             *\n             * @param {Element} from the element to copy attributes & state from\n             * @param {Element} to the element to copy attributes & state to\n             */\n            function syncNodeFrom(from, to) {\n                let type = from.nodeType\n\n                // if is an element type, sync the attributes from the\n                // new node into the new node\n                if (type === 1 /* element type */) {\n                    const fromAttributes = from.attributes;\n                    const toAttributes = to.attributes;\n                    for (const fromAttribute of fromAttributes) {\n                        if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                            to.setAttribute(fromAttribute.name, fromAttribute.value);\n                        }\n                    }\n                    for (const toAttribute of toAttributes) {\n                        if (!from.hasAttribute(toAttribute.name)) {\n                            to.removeAttribute(toAttribute.name);\n                        }\n                    }\n                }\n\n                // sync text nodes\n                if (type === 8 /* comment */ || type === 3 /* text */) {\n                    if (to.nodeValue !== from.nodeValue) {\n                        to.nodeValue = from.nodeValue;\n                    }\n                }\n\n                // NB: many bothans died to bring us information:\n                //\n                // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n                // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n                // sync input value\n                if (from instanceof HTMLInputElement &&\n                    to instanceof HTMLInputElement &&\n                    from.type !== 'file') {\n\n                    let fromValue = from.value;\n                    let toValue = to.value;\n\n                    // sync boolean attributes\n                    syncBooleanAttribute(from, to, 'checked');\n                    syncBooleanAttribute(from, to, 'disabled');\n\n                    if (!from.hasAttribute('value')) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    } else if (fromValue !== toValue) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                } else if (from instanceof HTMLOptionElement) {\n                    syncBooleanAttribute(from, to, 'selected')\n                } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                    let fromValue = from.value;\n                    let toValue = to.value;\n                    if (fromValue !== toValue) {\n                        to.value = fromValue;\n                    }\n                    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                        to.firstChild.nodeValue = fromValue\n                    }\n                }\n            }\n\n            function syncBooleanAttribute(from, to, attributeName) {\n                if (from[attributeName] !== to[attributeName]) {\n                    to[attributeName] = from[attributeName];\n                    if (from[attributeName]) {\n                        to.setAttribute(attributeName, '');\n                    } else {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n\n            //=============================================================================\n            // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n            //=============================================================================\n            function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n                let added = []\n                let removed = []\n                let preserved = []\n                let nodesToAppend = []\n\n                let headMergeStyle = ctx.head.style;\n\n                // put all new head elements into a Map, by their outerHTML\n                let srcToNewHeadNodes = new Map();\n                for (const newHeadChild of newHeadTag.children) {\n                    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n                }\n\n                // for each elt in the current head\n                for (const currentHeadElt of currentHead.children) {\n\n                    // If the current head element is in the map\n                    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                    let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                    let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                    if (inNewContent || isPreserved) {\n                        if (isReAppended) {\n                            // remove the current version and let the new version replace it and re-execute\n                            removed.push(currentHeadElt);\n                        } else {\n                            // this element already exists and should not be re-appended, so remove it from\n                            // the new content map, preserving it in the DOM\n                            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                            preserved.push(currentHeadElt);\n                        }\n                    } else {\n                        if (headMergeStyle === \"append\") {\n                            // we are appending and this existing element is not new content\n                            // so if and only if it is marked for re-append do we do anything\n                            if (isReAppended) {\n                                removed.push(currentHeadElt);\n                                nodesToAppend.push(currentHeadElt);\n                            }\n                        } else {\n                            // if this is a merge, we remove this content since it is not in the new head\n                            if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                                removed.push(currentHeadElt);\n                            }\n                        }\n                    }\n                }\n\n                // Push the remaining new head elements in the Map into the\n                // nodes to append to the head tag\n                nodesToAppend.push(...srcToNewHeadNodes.values());\n                log(\"to append: \", nodesToAppend);\n\n                let promises = [];\n                for (const newNode of nodesToAppend) {\n                    log(\"adding: \", newNode);\n                    let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                    log(newElt);\n                    if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                        if (newElt.href || newElt.src) {\n                            let resolve = null;\n                            let promise = new Promise(function (_resolve) {\n                                resolve = _resolve;\n                            });\n                            newElt.addEventListener('load',function() {\n                                resolve();\n                            });\n                            promises.push(promise);\n                        }\n                        currentHead.appendChild(newElt);\n                        ctx.callbacks.afterNodeAdded(newElt);\n                        added.push(newElt);\n                    }\n                }\n\n                // remove all removed elements, after we have appended the new elements to avoid\n                // additional network requests for things like style sheets\n                for (const removedElement of removed) {\n                    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                        currentHead.removeChild(removedElement);\n                        ctx.callbacks.afterNodeRemoved(removedElement);\n                    }\n                }\n\n                ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n                return promises;\n            }\n\n            //=============================================================================\n            // Misc\n            //=============================================================================\n\n            function log() {\n                //console.log(arguments);\n            }\n\n            function noOp() {}\n\n            function createMorphContext(oldNode, newContent, config) {\n                return {\n                    target:oldNode,\n                    newContent: newContent,\n                    config: config,\n                    morphStyle : config.morphStyle,\n                    ignoreActive : config.ignoreActive,\n                    idMap: createIdMap(oldNode, newContent),\n                    deadIds: new Set(),\n                    callbacks: Object.assign({\n                        beforeNodeAdded: noOp,\n                        afterNodeAdded : noOp,\n                        beforeNodeMorphed: noOp,\n                        afterNodeMorphed : noOp,\n                        beforeNodeRemoved: noOp,\n                        afterNodeRemoved : noOp,\n\n                    }, config.callbacks),\n                    head: Object.assign({\n                        style: 'merge',\n                        shouldPreserve : function(elt) {\n                            return elt.getAttribute(\"im-preserve\") === \"true\";\n                        },\n                        shouldReAppend : function(elt) {\n                            return elt.getAttribute(\"im-re-append\") === \"true\";\n                        },\n                        shouldRemove : noOp,\n                        afterHeadMorphed : noOp,\n                    }, config.head),\n                }\n            }\n\n            function isIdSetMatch(node1, node2, ctx) {\n                if (node1 == null || node2 == null) {\n                    return false;\n                }\n                if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                    if (node1.id !== \"\" && node1.id === node2.id) {\n                        return true;\n                    } else {\n                        return getIdIntersectionCount(ctx, node1, node2) > 0;\n                    }\n                }\n                return false;\n            }\n\n            function isSoftMatch(node1, node2) {\n                if (node1 == null || node2 == null) {\n                    return false;\n                }\n                return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n            }\n\n            function removeNodesBetween(startInclusive, endExclusive, ctx) {\n                while (startInclusive !== endExclusive) {\n                    let tempNode = startInclusive;\n                    startInclusive = startInclusive.nextSibling;\n                    removeNode(tempNode, ctx);\n                }\n                removeIdsFromConsideration(ctx, endExclusive);\n                return endExclusive.nextSibling;\n            }\n\n            //=============================================================================\n            // Scans forward from the insertionPoint in the old parent looking for a potential id match\n            // for the newChild.  We stop if we find a potential id match for the new child OR\n            // if the number of potential id matches we are discarding is greater than the\n            // potential id matches for the new child\n            //=============================================================================\n            function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n                // max id matches we are willing to discard in our search\n                let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n                let potentialMatch = null;\n\n                // only search forward if there is a possibility of an id match\n                if (newChildPotentialIdCount > 0) {\n                    let potentialMatch = insertionPoint;\n                    // if there is a possibility of an id match, scan forward\n                    // keep track of the potential id match count we are discarding (the\n                    // newChildPotentialIdCount must be greater than this to make it likely\n                    // worth it)\n                    let otherMatchCount = 0;\n                    while (potentialMatch != null) {\n\n                        // If we have an id match, return the current potential match\n                        if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                            return potentialMatch;\n                        }\n\n                        // computer the other potential matches of this new content\n                        otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                        if (otherMatchCount > newChildPotentialIdCount) {\n                            // if we have more potential id matches in _other_ content, we\n                            // do not have a good candidate for an id match, so return null\n                            return null;\n                        }\n\n                        // advanced to the next old content child\n                        potentialMatch = potentialMatch.nextSibling;\n                    }\n                }\n                return potentialMatch;\n            }\n\n            //=============================================================================\n            // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n            // for the newChild.  We stop if we find a potential soft match for the new child OR\n            // if we find a potential id match in the old parents children OR if we find two\n            // potential soft matches for the next two pieces of new content\n            //=============================================================================\n            function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n                let potentialSoftMatch = insertionPoint;\n                let nextSibling = newChild.nextSibling;\n                let siblingSoftMatchCount = 0;\n\n                while (potentialSoftMatch != null) {\n\n                    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                        // the current potential soft match has a potential id set match with the remaining new\n                        // content so bail out of looking\n                        return null;\n                    }\n\n                    // if we have a soft match with the current node, return it\n                    if (isSoftMatch(newChild, potentialSoftMatch)) {\n                        return potentialSoftMatch;\n                    }\n\n                    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                        // the next new node has a soft match with this node, so\n                        // increment the count of future soft matches\n                        siblingSoftMatchCount++;\n                        nextSibling = nextSibling.nextSibling;\n\n                        // If there are two future soft matches, bail to allow the siblings to soft match\n                        // so that we don't consume future soft matches for the sake of the current node\n                        if (siblingSoftMatchCount >= 2) {\n                            return null;\n                        }\n                    }\n\n                    // advanced to the next old content child\n                    potentialSoftMatch = potentialSoftMatch.nextSibling;\n                }\n\n                return potentialSoftMatch;\n            }\n\n            function parseContent(newContent) {\n                let parser = new DOMParser();\n\n                // remove svgs to avoid false-positive matches on head, etc.\n                let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n                // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n                if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                    let content = parser.parseFromString(newContent, \"text/html\");\n                    // if it is a full HTML document, return the document itself as the parent container\n                    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                        content.generatedByIdiomorph = true;\n                        return content;\n                    } else {\n                        // otherwise return the html element as the parent container\n                        let htmlElement = content.firstChild;\n                        if (htmlElement) {\n                            htmlElement.generatedByIdiomorph = true;\n                            return htmlElement;\n                        } else {\n                            return null;\n                        }\n                    }\n                } else {\n                    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                    // deal with touchy tags like tr, tbody, etc.\n                    let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                    let content = responseDoc.body.querySelector('template').content;\n                    content.generatedByIdiomorph = true;\n                    return content\n                }\n            }\n\n            function normalizeContent(newContent) {\n                if (newContent == null) {\n                    // noinspection UnnecessaryLocalVariableJS\n                    const dummyParent = document.createElement('div');\n                    return dummyParent;\n                } else if (newContent.generatedByIdiomorph) {\n                    // the template tag created by idiomorph parsing can serve as a dummy parent\n                    return newContent;\n                } else if (newContent instanceof Node) {\n                    // a single node is added as a child to a dummy parent\n                    const dummyParent = document.createElement('div');\n                    dummyParent.append(newContent);\n                    return dummyParent;\n                } else {\n                    // all nodes in the array or HTMLElement collection are consolidated under\n                    // a single dummy parent element\n                    const dummyParent = document.createElement('div');\n                    for (const elt of [...newContent]) {\n                        dummyParent.append(elt);\n                    }\n                    return dummyParent;\n                }\n            }\n\n            function insertSiblings(previousSibling, morphedNode, nextSibling) {\n                let stack = []\n                let added = []\n                while (previousSibling != null) {\n                    stack.push(previousSibling);\n                    previousSibling = previousSibling.previousSibling;\n                }\n                while (stack.length > 0) {\n                    let node = stack.pop();\n                    added.push(node); // push added preceding siblings on in order and insert\n                    morphedNode.parentElement.insertBefore(node, morphedNode);\n                }\n                added.push(morphedNode);\n                while (nextSibling != null) {\n                    stack.push(nextSibling);\n                    added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                    nextSibling = nextSibling.nextSibling;\n                }\n                while (stack.length > 0) {\n                    morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n                }\n                return added;\n            }\n\n            function findBestNodeMatch(newContent, oldNode, ctx) {\n                let currentElement;\n                currentElement = newContent.firstChild;\n                let bestElement = currentElement;\n                let score = 0;\n                while (currentElement) {\n                    let newScore = scoreElement(currentElement, oldNode, ctx);\n                    if (newScore > score) {\n                        bestElement = currentElement;\n                        score = newScore;\n                    }\n                    currentElement = currentElement.nextSibling;\n                }\n                return bestElement;\n            }\n\n            function scoreElement(node1, node2, ctx) {\n                if (isSoftMatch(node1, node2)) {\n                    return .5 + getIdIntersectionCount(ctx, node1, node2);\n                }\n                return 0;\n            }\n\n            function removeNode(tempNode, ctx) {\n                removeIdsFromConsideration(ctx, tempNode)\n                ctx.callbacks.beforeNodeRemoved(tempNode);\n                tempNode.remove();\n                ctx.callbacks.afterNodeRemoved(tempNode);\n            }\n\n            //=============================================================================\n            // ID Set Functions\n            //=============================================================================\n\n            function isIdInConsideration(ctx, id) {\n                return !ctx.deadIds.has(id);\n            }\n\n            function idIsWithinNode(ctx, id, targetNode) {\n                let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n                return idSet.has(id);\n            }\n\n            function removeIdsFromConsideration(ctx, node) {\n                let idSet = ctx.idMap.get(node) || EMPTY_SET;\n                for (const id of idSet) {\n                    ctx.deadIds.add(id);\n                }\n            }\n\n            function getIdIntersectionCount(ctx, node1, node2) {\n                let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n                let matchCount = 0;\n                for (const id of sourceSet) {\n                    // a potential match is an id in the source and potentialIdsSet, but\n                    // that has not already been merged into the DOM\n                    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                        ++matchCount;\n                    }\n                }\n                return matchCount;\n            }\n\n            /**\n             * A bottom up algorithm that finds all elements with ids inside of the node\n             * argument and populates id sets for those nodes and all their parents, generating\n             * a set of ids contained within all nodes for the entire hierarchy in the DOM\n             *\n             * @param node {Element}\n             * @param {Map<Node, Set<String>>} idMap\n             */\n            function populateIdMapForNode(node, idMap) {\n                let nodeParent = node.parentElement;\n                // find all elements with an id property\n                let idElements = node.querySelectorAll('[id]');\n                for (const elt of idElements) {\n                    let current = elt;\n                    // walk up the parent hierarchy of that element, adding the id\n                    // of element to the parent's id set\n                    while (current !== nodeParent && current != null) {\n                        let idSet = idMap.get(current);\n                        // if the id set doesn't exist, create it and insert it in the  map\n                        if (idSet == null) {\n                            idSet = new Set();\n                            idMap.set(current, idSet);\n                        }\n                        idSet.add(elt.id);\n                        current = current.parentElement;\n                    }\n                }\n            }\n\n            /**\n             * This function computes a map of nodes to all ids contained within that node (inclusive of the\n             * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n             * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n             * to contribute to a parent nodes matching.\n             *\n             * @param {Element} oldContent  the old content that will be morphed\n             * @param {Element} newContent  the new content to morph to\n             * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n             */\n            function createIdMap(oldContent, newContent) {\n                let idMap = new Map();\n                populateIdMapForNode(oldContent, idMap);\n                populateIdMapForNode(newContent, idMap);\n                return idMap;\n            }\n\n            //=============================================================================\n            // This is what ends up becoming the Idiomorph global object\n            //=============================================================================\n            return {\n                morph\n            }\n        })()\n    }));\n\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar Event = /** @class */ (function () {\r\n    function Event(type, target) {\r\n        this.target = target;\r\n        this.type = type;\r\n    }\r\n    return Event;\r\n}());\r\nvar ErrorEvent = /** @class */ (function (_super) {\r\n    __extends(ErrorEvent, _super);\r\n    function ErrorEvent(error, target) {\r\n        var _this = _super.call(this, 'error', target) || this;\r\n        _this.message = error.message;\r\n        _this.error = error;\r\n        return _this;\r\n    }\r\n    return ErrorEvent;\r\n}(Event));\r\nvar CloseEvent = /** @class */ (function (_super) {\r\n    __extends(CloseEvent, _super);\r\n    function CloseEvent(code, reason, target) {\r\n        if (code === void 0) { code = 1000; }\r\n        if (reason === void 0) { reason = ''; }\r\n        var _this = _super.call(this, 'close', target) || this;\r\n        _this.wasClean = true;\r\n        _this.code = code;\r\n        _this.reason = reason;\r\n        return _this;\r\n    }\r\n    return CloseEvent;\r\n}(Event));\n\n/*!\r\n * Reconnecting WebSocket\r\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\r\n * https://github.com/pladaria/reconnecting-websocket\r\n * License MIT\r\n */\r\nvar getGlobalWebSocket = function () {\r\n    if (typeof WebSocket !== 'undefined') {\r\n        // @ts-ignore\r\n        return WebSocket;\r\n    }\r\n};\r\n/**\r\n * Returns true if given argument looks like a WebSocket class\r\n */\r\nvar isWebSocket = function (w) { return typeof w !== 'undefined' && !!w && w.CLOSING === 2; };\r\nvar DEFAULT = {\r\n    maxReconnectionDelay: 10000,\r\n    minReconnectionDelay: 1000 + Math.random() * 4000,\r\n    minUptime: 5000,\r\n    reconnectionDelayGrowFactor: 1.3,\r\n    connectionTimeout: 4000,\r\n    maxRetries: Infinity,\r\n    maxEnqueuedMessages: Infinity,\r\n    startClosed: false,\r\n    debug: false,\r\n};\r\nvar ReconnectingWebSocket = /** @class */ (function () {\r\n    function ReconnectingWebSocket(url, protocols, options) {\r\n        var _this = this;\r\n        if (options === void 0) { options = {}; }\r\n        this._listeners = {\r\n            error: [],\r\n            message: [],\r\n            open: [],\r\n            close: [],\r\n        };\r\n        this._retryCount = -1;\r\n        this._shouldReconnect = true;\r\n        this._connectLock = false;\r\n        this._binaryType = 'blob';\r\n        this._closeCalled = false;\r\n        this._messageQueue = [];\r\n        /**\r\n         * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\r\n         */\r\n        this.onclose = null;\r\n        /**\r\n         * An event listener to be called when an error occurs\r\n         */\r\n        this.onerror = null;\r\n        /**\r\n         * An event listener to be called when a message is received from the server\r\n         */\r\n        this.onmessage = null;\r\n        /**\r\n         * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\r\n         * this indicates that the connection is ready to send and receive data\r\n         */\r\n        this.onopen = null;\r\n        this._handleOpen = function (event) {\r\n            _this._debug('open event');\r\n            var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;\r\n            clearTimeout(_this._connectTimeout);\r\n            _this._uptimeTimeout = setTimeout(function () { return _this._acceptOpen(); }, minUptime);\r\n            _this._ws.binaryType = _this._binaryType;\r\n            // send enqueued messages (messages sent before websocket open event)\r\n            _this._messageQueue.forEach(function (message) { return _this._ws.send(message); });\r\n            _this._messageQueue = [];\r\n            if (_this.onopen) {\r\n                _this.onopen(event);\r\n            }\r\n            _this._listeners.open.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._handleMessage = function (event) {\r\n            _this._debug('message event');\r\n            if (_this.onmessage) {\r\n                _this.onmessage(event);\r\n            }\r\n            _this._listeners.message.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._handleError = function (event) {\r\n            _this._debug('error event', event.message);\r\n            _this._disconnect(undefined, event.message === 'TIMEOUT' ? 'timeout' : undefined);\r\n            if (_this.onerror) {\r\n                _this.onerror(event);\r\n            }\r\n            _this._debug('exec error listeners');\r\n            _this._listeners.error.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n            _this._connect();\r\n        };\r\n        this._handleClose = function (event) {\r\n            _this._debug('close event');\r\n            _this._clearTimeouts();\r\n            if (_this._shouldReconnect) {\r\n                _this._connect();\r\n            }\r\n            if (_this.onclose) {\r\n                _this.onclose(event);\r\n            }\r\n            _this._listeners.close.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._url = url;\r\n        this._protocols = protocols;\r\n        this._options = options;\r\n        if (this._options.startClosed) {\r\n            this._shouldReconnect = false;\r\n        }\r\n        this._connect();\r\n    }\r\n    Object.defineProperty(ReconnectingWebSocket, \"CONNECTING\", {\r\n        get: function () {\r\n            return 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"OPEN\", {\r\n        get: function () {\r\n            return 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"CLOSING\", {\r\n        get: function () {\r\n            return 2;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"CLOSED\", {\r\n        get: function () {\r\n            return 3;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CONNECTING\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CONNECTING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"OPEN\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.OPEN;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CLOSING\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CLOSING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CLOSED\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CLOSED;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"binaryType\", {\r\n        get: function () {\r\n            return this._ws ? this._ws.binaryType : this._binaryType;\r\n        },\r\n        set: function (value) {\r\n            this._binaryType = value;\r\n            if (this._ws) {\r\n                this._ws.binaryType = value;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"retryCount\", {\r\n        /**\r\n         * Returns the number or connection retries\r\n         */\r\n        get: function () {\r\n            return Math.max(this._retryCount, 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"bufferedAmount\", {\r\n        /**\r\n         * The number of bytes of data that have been queued using calls to send() but not yet\r\n         * transmitted to the network. This value resets to zero once all queued data has been sent.\r\n         * This value does not reset to zero when the connection is closed; if you keep calling send(),\r\n         * this will continue to climb. Read only\r\n         */\r\n        get: function () {\r\n            var bytes = this._messageQueue.reduce(function (acc, message) {\r\n                if (typeof message === 'string') {\r\n                    acc += message.length; // not byte size\r\n                }\r\n                else if (message instanceof Blob) {\r\n                    acc += message.size;\r\n                }\r\n                else {\r\n                    acc += message.byteLength;\r\n                }\r\n                return acc;\r\n            }, 0);\r\n            return bytes + (this._ws ? this._ws.bufferedAmount : 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"extensions\", {\r\n        /**\r\n         * The extensions selected by the server. This is currently only the empty string or a list of\r\n         * extensions as negotiated by the connection\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.extensions : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"protocol\", {\r\n        /**\r\n         * A string indicating the name of the sub-protocol the server selected;\r\n         * this will be one of the strings specified in the protocols parameter when creating the\r\n         * WebSocket object\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.protocol : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"readyState\", {\r\n        /**\r\n         * The current state of the connection; this is one of the Ready state constants\r\n         */\r\n        get: function () {\r\n            if (this._ws) {\r\n                return this._ws.readyState;\r\n            }\r\n            return this._options.startClosed\r\n                ? ReconnectingWebSocket.CLOSED\r\n                : ReconnectingWebSocket.CONNECTING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"url\", {\r\n        /**\r\n         * The URL as resolved by the constructor\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.url : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt, if any. If the connection is already\r\n     * CLOSED, this method does nothing\r\n     */\r\n    ReconnectingWebSocket.prototype.close = function (code, reason) {\r\n        if (code === void 0) { code = 1000; }\r\n        this._closeCalled = true;\r\n        this._shouldReconnect = false;\r\n        this._clearTimeouts();\r\n        if (!this._ws) {\r\n            this._debug('close enqueued: no ws instance');\r\n            return;\r\n        }\r\n        if (this._ws.readyState === this.CLOSED) {\r\n            this._debug('close: already closed');\r\n            return;\r\n        }\r\n        this._ws.close(code, reason);\r\n    };\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt and connects again.\r\n     * Resets retry counter;\r\n     */\r\n    ReconnectingWebSocket.prototype.reconnect = function (code, reason) {\r\n        this._shouldReconnect = true;\r\n        this._closeCalled = false;\r\n        this._retryCount = -1;\r\n        if (!this._ws || this._ws.readyState === this.CLOSED) {\r\n            this._connect();\r\n        }\r\n        else {\r\n            this._disconnect(code, reason);\r\n            this._connect();\r\n        }\r\n    };\r\n    /**\r\n     * Enqueue specified data to be transmitted to the server over the WebSocket connection\r\n     */\r\n    ReconnectingWebSocket.prototype.send = function (data) {\r\n        if (this._ws && this._ws.readyState === this.OPEN) {\r\n            this._debug('send', data);\r\n            this._ws.send(data);\r\n        }\r\n        else {\r\n            var _a = this._options.maxEnqueuedMessages, maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;\r\n            if (this._messageQueue.length < maxEnqueuedMessages) {\r\n                this._debug('enqueue', data);\r\n                this._messageQueue.push(data);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Register an event handler of a specific event type\r\n     */\r\n    ReconnectingWebSocket.prototype.addEventListener = function (type, listener) {\r\n        if (this._listeners[type]) {\r\n            // @ts-ignore\r\n            this._listeners[type].push(listener);\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype.dispatchEvent = function (event) {\r\n        var e_1, _a;\r\n        var listeners = this._listeners[event.type];\r\n        if (listeners) {\r\n            try {\r\n                for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\r\n                    var listener = listeners_1_1.value;\r\n                    this._callEventListener(event, listener);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Removes an event listener\r\n     */\r\n    ReconnectingWebSocket.prototype.removeEventListener = function (type, listener) {\r\n        if (this._listeners[type]) {\r\n            // @ts-ignore\r\n            this._listeners[type] = this._listeners[type].filter(function (l) { return l !== listener; });\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._debug = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this._options.debug) {\r\n            // not using spread because compiled version uses Symbols\r\n            // tslint:disable-next-line\r\n            console.log.apply(console, __spread(['RWS>'], args));\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._getNextDelay = function () {\r\n        var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;\r\n        var delay = 0;\r\n        if (this._retryCount > 0) {\r\n            delay =\r\n                minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\r\n            if (delay > maxReconnectionDelay) {\r\n                delay = maxReconnectionDelay;\r\n            }\r\n        }\r\n        this._debug('next delay', delay);\r\n        return delay;\r\n    };\r\n    ReconnectingWebSocket.prototype._wait = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            setTimeout(resolve, _this._getNextDelay());\r\n        });\r\n    };\r\n    ReconnectingWebSocket.prototype._getNextUrl = function (urlProvider) {\r\n        if (typeof urlProvider === 'string') {\r\n            return Promise.resolve(urlProvider);\r\n        }\r\n        if (typeof urlProvider === 'function') {\r\n            var url = urlProvider();\r\n            if (typeof url === 'string') {\r\n                return Promise.resolve(url);\r\n            }\r\n            if (!!url.then) {\r\n                return url;\r\n            }\r\n        }\r\n        throw Error('Invalid URL');\r\n    };\r\n    ReconnectingWebSocket.prototype._connect = function () {\r\n        var _this = this;\r\n        if (this._connectLock || !this._shouldReconnect) {\r\n            return;\r\n        }\r\n        this._connectLock = true;\r\n        var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket = _d === void 0 ? getGlobalWebSocket() : _d;\r\n        if (this._retryCount >= maxRetries) {\r\n            this._debug('max retries reached', this._retryCount, '>=', maxRetries);\r\n            return;\r\n        }\r\n        this._retryCount++;\r\n        this._debug('connect', this._retryCount);\r\n        this._removeListeners();\r\n        if (!isWebSocket(WebSocket)) {\r\n            throw Error('No valid WebSocket class provided');\r\n        }\r\n        this._wait()\r\n            .then(function () { return _this._getNextUrl(_this._url); })\r\n            .then(function (url) {\r\n            // close could be called before creating the ws\r\n            if (_this._closeCalled) {\r\n                return;\r\n            }\r\n            _this._debug('connect', { url: url, protocols: _this._protocols });\r\n            _this._ws = _this._protocols\r\n                ? new WebSocket(url, _this._protocols)\r\n                : new WebSocket(url);\r\n            _this._ws.binaryType = _this._binaryType;\r\n            _this._connectLock = false;\r\n            _this._addListeners();\r\n            _this._connectTimeout = setTimeout(function () { return _this._handleTimeout(); }, connectionTimeout);\r\n        });\r\n    };\r\n    ReconnectingWebSocket.prototype._handleTimeout = function () {\r\n        this._debug('timeout event');\r\n        this._handleError(new ErrorEvent(Error('TIMEOUT'), this));\r\n    };\r\n    ReconnectingWebSocket.prototype._disconnect = function (code, reason) {\r\n        if (code === void 0) { code = 1000; }\r\n        this._clearTimeouts();\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._removeListeners();\r\n        try {\r\n            this._ws.close(code, reason);\r\n            this._handleClose(new CloseEvent(code, reason, this));\r\n        }\r\n        catch (error) {\r\n            // ignore\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._acceptOpen = function () {\r\n        this._debug('accept open');\r\n        this._retryCount = 0;\r\n    };\r\n    ReconnectingWebSocket.prototype._callEventListener = function (event, listener) {\r\n        if ('handleEvent' in listener) {\r\n            // @ts-ignore\r\n            listener.handleEvent(event);\r\n        }\r\n        else {\r\n            // @ts-ignore\r\n            listener(event);\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._removeListeners = function () {\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._debug('removeListeners');\r\n        this._ws.removeEventListener('open', this._handleOpen);\r\n        this._ws.removeEventListener('close', this._handleClose);\r\n        this._ws.removeEventListener('message', this._handleMessage);\r\n        // @ts-ignore\r\n        this._ws.removeEventListener('error', this._handleError);\r\n    };\r\n    ReconnectingWebSocket.prototype._addListeners = function () {\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._debug('addListeners');\r\n        this._ws.addEventListener('open', this._handleOpen);\r\n        this._ws.addEventListener('close', this._handleClose);\r\n        this._ws.addEventListener('message', this._handleMessage);\r\n        // @ts-ignore\r\n        this._ws.addEventListener('error', this._handleError);\r\n    };\r\n    ReconnectingWebSocket.prototype._clearTimeouts = function () {\r\n        clearTimeout(this._connectTimeout);\r\n        clearTimeout(this._uptimeTimeout);\r\n    };\r\n    return ReconnectingWebSocket;\r\n}());\n\nexport default ReconnectingWebSocket;\n", "import _load from \"idiomorph\";\n\nfunction morph(oldNode, newNode) {\n  Idiomorph.morph(oldNode, newNode);\n}\n\nconst BOOST_PAGES = JSON.parse(\n  document.querySelector(\"meta[name=reactor-boost]\")?.dataset.enabled || \"false\"\n);\n\nconsole.log(\"BOOST_PAGES\", BOOST_PAGES);\n\nclass NavEvents extends EventTarget {\n  sendNewLocation() {\n    console.log(\"LOAD\", document.location.href);\n    this.dispatchEvent(new Event(\"newLocation\"));\n  }\n\n  sendNewContent() {\n    this.dispatchEvent(new Event(\"newContent\"));\n  }\n}\n\nlet navEvent = new NavEvents();\n\nif (BOOST_PAGES) {\n  document.addEventListener(\"click\", (e) => {\n    let link = e.target;\n    link = link.tagName.toLowerCase() !== \"a\" ? link.closest(\"a\") : link;\n    if (\n      link &&\n      link.href &&\n      (!link.target || link.target === \"_self\") &&\n      link.origin == document.location.origin &&\n      e.button === 0 && // left click only\n      !e.metaKey && // open in new tab (mac)\n      !e.ctrlKey && // open in new tab (win & linux)\n      !e.altKey && // download\n      !e.shiftKey\n    ) {\n      e.preventDefault();\n      HistoryCache.load(link.href);\n    }\n  });\n}\n\nfunction replaceBodyContent(newBody, scrollY = undefined) {\n  window.requestAnimationFrame(() => {\n    morph(document.body, newBody);\n    if (scrollY === undefined) {\n      document.querySelector(\"[autofocus]\")?.focus();\n    } else {\n      window.scrollTo(0, scrollY);\n    }\n    navEvent.sendNewContent();\n  });\n}\n\nfunction hasSameOriginAsDocument(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return new URL(url).origin === document.location.origin;\n  } else {\n    return true;\n  }\n}\n\nclass HistoryCache {\n  static async load(url) {\n    if (BOOST_PAGES) {\n      // this._saveCurrentPage();\n      if (hasSameOriginAsDocument(url)) {\n        this.push(url);\n      } else {\n        document.location.assign(url);\n      }\n    } else {\n      document.location.assign(url);\n    }\n  }\n\n  static back() {\n    window.history.back();\n  }\n\n  static async push(path) {\n    if (document.body == null) debugger;\n    history.replaceState(\n      {\n        content: document.body.outerHTML,\n        scrollY: window.scrollY,\n      },\n      document.title,\n      document.location.href\n    );\n    history.pushState({}, document.title, path);\n    this.replaceContentFromUrl(path);\n  }\n\n  static async replaceContentFromUrl(url) {\n    navEvent.sendNewLocation();\n    let response = await fetch(url);\n    let content = await response.text();\n    let doc = new DOMParser().parseFromString(content, \"text/html\");\n    document.title = doc.querySelector(\"title\")?.text ?? \"\";\n    replaceBodyContent(doc.body);\n  }\n\n  static replace(path) {\n    history.replaceState({}, document.title, path);\n  }\n}\n\nwindow.addEventListener(\"popstate\", (event) => {\n  navEvent.sendNewLocation();\n  if (event.state?.content !== undefined) {\n    replaceBodyContent(event.state.content, event.state.scrollY);\n  }\n  HistoryCache.replaceContentFromUrl(document.location.href);\n});\n\nexport default {\n  HistoryCache: HistoryCache,\n  morph: morph,\n  navEvent: navEvent,\n};\n", "import ReconnectingWebSocket from \"reconnecting-websocket\";\nimport boost from \"./reactor-boost\";\n\n// Connection\n\nconst parser = new DOMParser();\n\nclass ServerConnection {\n  constructor() {\n    this.components = {};\n  }\n\n  open(path = \"__reactor__\") {\n    let protocol = location.protocol.replace(\"http\", \"ws\");\n    this.socket = new ReconnectingWebSocket(\n      `${protocol}//${location.host}/${path}`,\n      [],\n      {\n        maxEnqueuedMessages: 0,\n      }\n    );\n\n    this.socket.addEventListener(\"open\", () => {\n      console.log(\"WS: OPEN\");\n      this.sendQueryString();\n      this.components = {};\n      this.joinAllComponents();\n    });\n\n    this.socket.addEventListener(\"message\", (event) =>\n      this._processMessage(event)\n    );\n\n    this.socket.addEventListener(\"close\", () => {\n      console.log(\"WS: CLOSE\");\n      this.components = {};\n      document.querySelectorAll(\"[reactor-component]\").forEach((element) => {\n        element.classList.add(\"reactor-disconnected\");\n        element.dataset.isLive = \"false\";\n      });\n    });\n\n    boost.navEvent.addEventListener(\"newLocation\", () => {\n      this.sendQueryString();\n    });\n\n    boost.navEvent.addEventListener(\"newContent\", () => {\n      this.joinAllComponents();\n    });\n  }\n\n  get isOpen() {\n    return this.socket?.readyState == ReconnectingWebSocket.OPEN;\n  }\n\n  joinAllComponents() {\n    let registeredIds = new Set(Object.keys(this.components));\n    for (let element of document.querySelectorAll(\"[reactor-component]\")) {\n      if (registeredIds.delete(element.id)) {\n        this.components[element.id].join();\n      } else {\n        let component = new ReactorComponent(element.id);\n        this.components[element.id] = component;\n        component.join();\n      }\n    }\n    for (let id of registeredIds.keys()) {\n      delete this.components[id];\n      this.sendLeave(id);\n    }\n  }\n\n  _processMessage(event) {\n    let { command, payload } = JSON.parse(event.data);\n    switch (command) {\n      case \"render\":\n        var { id, diff } = payload;\n        console.log(\"<<< RENDER\", id);\n        this.components[id]?.applyDiff(diff);\n        break;\n      case \"append\":\n      case \"prepend\":\n      case \"insert_after\":\n      case \"insert_before\":\n      case \"replace_with\":\n        var { id, html } = payload;\n        console.log(`<<< ${command.toUpperCase()}`, id);\n        html = parser.parseFromString(html, \"text/html\").body.firstChild;\n        var element = document.getElementById(id);\n        if (element) {\n          switch (command) {\n            case \"append\":\n              element.append(html);\n              break;\n            case \"prepend\":\n              element.prepend(html);\n              break;\n            case \"insert_after\":\n              element.after(html);\n              break;\n            case \"insert_before\":\n              element.before(html);\n              break;\n            case \"replace_with\":\n              boost.morph(element, html);\n              break;\n          }\n          boost.navEvent.sendNewContent();\n        }\n        break;\n      case \"remove\":\n        var { id } = payload;\n        console.log(\"<<< REMOVE\", id);\n        document.getElementById(id)?.remove();\n        boost.navEvent.sendNewContent();\n        break;\n      case \"focus_on\":\n        var { selector } = payload;\n        console.log(\n          \"<<< FOCUS-ON\",\n          `\"${selector}\"`,\n          document.querySelector(selector)\n        );\n        window.requestAnimationFrame(() =>\n          document.querySelector(selector)?.focus()\n        );\n        break;\n      case \"scroll_into_view\":\n        var { id, behavior, block, inline } = payload;\n        window.requestAnimationFrame(() =>\n          document\n            .getElementById(id)\n            ?.scrollIntoView({ behavior, block, inline })\n        );\n        break;\n      case \"url_change\":\n        var { url } = payload;\n        console.log(\"<< URL\", payload.command, url);\n        switch (payload.command) {\n          case \"redirect\":\n            boost.HistoryCache.load(url);\n            break;\n          case \"replace\":\n            boost.HistoryCache.replace(url);\n            break;\n          case \"push\":\n            boost.HistoryCache.push(url);\n            break;\n        }\n        break;\n\n      case \"set_query_string\":\n        var { qs } = payload;\n        qs = qs.length ? `?${qs}` : \"\";\n        console.log(\"<< SET URL PARAMS\", qs);\n        boost.HistoryCache.replace(document.location.pathname + qs);\n        break;\n\n      case \"back\":\n        boost.HistoryCache.back();\n        break;\n      default:\n        console.error(`Unknown command \"${command}\"`, payload);\n    }\n  }\n\n  sendQueryString() {\n    // \"?a=x&...\" -> \"a=x&...\"\n    let qs = document.location.search.slice(1);\n    console.log(\"QS\", qs);\n    this._send(\"query_string\", { qs });\n  }\n\n  sendJoin(name, component_id, state, children) {\n    console.log(\">>> JOIN\", name, component_id);\n    this._send(\"join\", { name, state, children });\n  }\n\n  sendLeave(id) {\n    console.log(\">>> LEAVE\", id);\n    this._send(\"leave\", { id });\n  }\n\n  sendUserEvent(id, command, implicit_args, explicit_args) {\n    console.log(\">>> USER_EVENT\", id, command, explicit_args);\n    this._send(\"user_event\", { id, command, implicit_args, explicit_args });\n  }\n\n  _send(command, payload) {\n    if (this.isOpen) {\n      this.socket.send(JSON.stringify({ command, payload }));\n    }\n  }\n}\n\nlet connection = new ServerConnection();\n\nclass ReactorComponent {\n  /**\n   * Returns the id of the parent component\n   *\n   * @param {HTMLElement} el\n   */\n  constructor(id) {\n    this.id = id;\n    this.lastReceivedHtml = [];\n  }\n\n  getElemenet() {\n    return document.getElementById(this.id);\n  }\n\n  applyDiff(diff) {\n    window.requestAnimationFrame(() => {\n      let el = this.getElemenet();\n      if (el) {\n        let html = this.getHtml(diff);\n        boost.morph(el, html);\n        boost.navEvent.sendNewContent();\n      }\n    });\n  }\n\n  getHtml(diff) {\n    let fragments = [];\n    let cursor = 0;\n    for (let fragment of diff) {\n      if (typeof fragment === \"string\") {\n        fragments.push(fragment);\n      } else if (fragment < 0) {\n        cursor -= fragment;\n      } else {\n        fragments.push(\n          ...this.lastReceivedHtml.slice(cursor, cursor + fragment)\n        );\n        cursor += fragment;\n      }\n    }\n    this.lastReceivedHtml = fragments;\n    return fragments.join(\" \");\n  }\n\n  join() {\n    let element = this.getElemenet();\n    if (element && element.dataset.isLive === \"false\") {\n      let parent = element?.parentElement?.closest(\"[reactor-component]\");\n      if (!parent || parent.dataset.isLive === \"true\") {\n        element.dataset.isLive = \"true\";\n        let children = Array.from(\n          element.querySelectorAll(\"[reactor-component]\")\n        ).reduce((children, el) => {\n          children[el.id] = [el.dataset.name, el.dataset.state];\n          return children;\n        }, {});\n\n        connection.sendJoin(\n          element.dataset.name,\n          element.id,\n          element.dataset.state,\n          children\n        );\n      }\n    }\n  }\n\n  /**\n   * Dispatches a command to this component and sends it to the backend\n   * @param {String} command\n   * @param {Object} args\n   * @param {?HTMLFormElement} form\n   */\n  dispatch(command, args, formScope) {\n    connection.sendUserEvent(this.id, command, this.serialize(formScope), args);\n  }\n\n  /**\n   * Serialize all elements inside `element` with a [name] attribute into\n   * a an array of `[element[name], element[value]]`\n   * @param {HTMLElement} element\n   */\n  serialize(element) {\n    let result = {};\n    let thisElement = this.getElemenet();\n    for (let el of element.querySelectorAll(\"[name]\")) {\n      // Avoid serializing data of a nested component\n      if (el.closest(\"[reactor-component]\") !== thisElement) {\n        continue;\n      }\n\n      let value = null;\n      switch (el.type.toLowerCase()) {\n        case \"checkbox\":\n        case \"radio\":\n          value = el.checked ? el.value || true : null;\n          break;\n        case \"select-multiple\":\n          value = el.selectedOptions.map((option) => option.value);\n          break;\n        default:\n          value = el.value;\n          break;\n      }\n\n      if (value !== null) {\n        let key = el.getAttribute(\"name\");\n        let values = result[key] ?? [];\n        values.push(value);\n        result[key] = values;\n      }\n    }\n    return result;\n  }\n}\n\nconnection.open();\nvar debounceTimeout = undefined;\n\nwindow.reactor = {\n  /**\n   * Forwards a user event to a component\n   * @param {HTMLElement} element\n   * @param {String} name\n   * @param {Object} args\n   */\n  send(element, name, args) {\n    let component_el = element.closest(\"[reactor-component]\");\n    let component = connection.components[component_el.id];\n    if (component_el !== null && component !== undefined) {\n      let form = element.closest(\"form\");\n      let formScope = component_el.contains(form) ? form : component_el;\n      component.dispatch(name, args, formScope);\n    }\n  },\n\n  /**\n   * Debounce a function call\n   * @param {Number} delay\n   * @returns\n   */\n  debounce(delay) {\n    return (f) => {\n      return (...args) => {\n        clearTimeout(debounceTimeout);\n        debounceTimeout = setTimeout(() => f(...args), delay);\n      };\n    };\n  },\n};\n"],
  "mappings": "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",
  "names": []
}
