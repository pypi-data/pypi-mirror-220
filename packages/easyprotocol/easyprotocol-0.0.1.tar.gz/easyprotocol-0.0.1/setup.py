# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['easyprotocol',
 'easyprotocol.base',
 'easyprotocol.fields',
 'easyprotocol.protocols',
 'easyprotocol.protocols.modbus']

package_data = \
{'': ['*']}

install_requires = \
['bitarray>=2.6.0,<3.0.0', 'crc>=2.0.0,<3.0.0']

setup_kwargs = {
    'name': 'easyprotocol',
    'version': '0.0.1',
    'description': 'A library for quick protocol prototyping and parsing.',
    'long_description': '# EasyProtocol\n\n## Introduction\n\nA library for quick prototyping protocol parsing in python. Not the fastest, not the most efficient, not the coolest, but hopefully the easiest to modify and prototype with.\n\n## Quick Start\n\n### Installing\n\nFor now you have to install from source, this will be on pypi soon.\n\n- Current Method\n\n```bash\ngit clone https://github.com/joeferg425/EasyProtocol.git .\ncd EasyProtocol\npython -m pip install .\n```\n\n- Future, better method\n\n```bash\npython -m pip install easyprotocol\n```\n\n### Example 1 - Making a Parser From a List of Fields\n\n- Demo Code\n\n    Lets parse something like the following.\n\n    | Name       | Bit Count | Data Type           |\n    |:--         |:--        |:--                  |\n    | id         | 8         | 8-bit int           |\n    | data count | 16        | 16-bit unsigned int |\n    | data       | 8         | 8-bit unsigned int  |\n\n    Fixed frame definition. Nothing fancy.\n\n    ```python\n    """Define your parser using simple python classes and familiar types."""\n    from easyprotocol.base import ParseFieldList, hex\n    from easyprotocol.fields import Int8Field, UInt8Field, UInt16Field\n\n    # Make an instance of the modified list type and add your fields as the list items.\n    exampleParser = ParseFieldList(\n        # give the parser a name\n        name="ExampleParser1",\n        # define your fields in order\n        default=[\n            # give each field a name, some standard field types are already defined.\n            Int8Field(name="id"),\n            UInt16Field(name="count"),\n            UInt8Field(name="data"),\n        ],\n    )\n\n    # Some example data bytes to parse\n    data = b"\\x01\\x00\\x01\\x80"\n    print(f"input bytes:\\t{data!r}")\n    print(f"input hex:\\t{hex(data)}\\n")\n\n    # Parse the bytes\n    exampleParser.parse(data=data)\n\n    # Print the parsed data to see what we got\n    print(f"parsed:\\t{exampleParser}")\n    print(f"bytes:\\t{bytes(exampleParser)!r}")\n    print(f"hex:\\t{exampleParser.hex_value}\\n")\n\n    # Make a new frame from known data to send somewhere (like a socket)\n    exampleParser[0].value = 3\n    exampleParser.value = [3, 257, 127]\n    exampleParser.value = [3, 257, 127]\n    print(f"parsed:\\t{exampleParser}")\n    print(f"bytes:\\t{bytes(exampleParser)!r}")\n    print(f"hex:\\t{exampleParser.hex_value}\\n")\n\n    # You can access parsed elements of a ParseList by numeric index.\n    for child in exampleParser.children.values():\n        print(f\'{child.name}:\\t{child.value}\\t"{child.string_value}"\')\n    print()\n\n    # Wait, I don\'t really like hexadecimal\n    exampleParser.string_format = "{}"\n    for child in exampleParser.children.values():\n        child.string_format = "{}"\n\n    # Print the values again\n    exampleParser[0].value = 3\n    exampleParser.value = [3, 257, 127]\n    exampleParser.value = [3, 257, 127]\n    print(f"parsed:\\t{exampleParser}")\n    print(f"bytes:\\t{bytes(exampleParser)!r}")\n    print(f"hex:\\t{exampleParser.hex_value}\\n")\n    for child in exampleParser.children.values():\n        print(f\'{child.name}:\\t{child.value}\\t"{child.string_value}"\')\n    ```\n\n- Output\n\n    ```bash\n    input bytes:    b\'\\x01\\x00\\x01\\x80\'\n    input hex:      01 00 01 80\n\n    parsed: ExampleParser1: [id: 1, count: 0001(hex), data: 80(hex)]\n    bytes:  b\'\\x01\\x00\\x01\\x80\'\n    hex:    01 00 01 80\n\n    parsed: ExampleParser1: [id: 3, count: 0101(hex), data: 7F(hex)]\n    bytes:  b\'\\x03\\x01\\x01\\x7f\'\n    hex:    03 01 01 7F\n\n    id:     3       "3"\n    count:  257     "0101(hex)"\n    data:   127     "7F(hex)"\n\n    parsed: ExampleParser1: [id: 3, count: 257, data: 127]\n    bytes:  b\'\\x03\\x01\\x01\\x7f\'\n    hex:    03 01 01 7F\n\n    id:     3       "3"\n    count:  257     "257"\n    data:   127     "127"\n        ```\n\n### Example 2 - Making a Parser from a Dictionary of Fields\n\n- Demo Code\n\n    Lets parse something like the following.\n\n    | Name       | Bit Count | Data Type              |\n    |:--         |:--        |:--                     |\n    | id         | 8         | 8-bit unsigned int     |\n    | count      | 16        | 16-bit unsigned int    |\n    | data array | 8         | 8-bit unsigned int(s)  |\n\n    Variable Frame size, handles a variable length array of uint8 chunks.\n\n    ```python\n    """Define your parser using simple python classes and familiar types."""\n    from typing import cast\n\n    from easyprotocol.base import ParseFieldDict, ParseFieldList, hex\n    from easyprotocol.fields import Int8Field, ParseArrayField, UInt8Field, UInt16Field\n\n    # you can define your field classes before using them in a parser.\n    ident = Int8Field(name="id")\n    count = UInt16Field(\n        name="count",\n        # Let\'s modify the display of the field value\n        string_format="{} data items",\n    )\n    data_array = ParseArrayField(\n        name="data",\n        count=count,\n        array_item_class=UInt8Field,\n        array_item_default=0,\n    )\n\n    # Make an instance of the modified list type and add your fields as the list items.\n    exampleParser = ParseFieldDict(\n        # give the parser a name\n        name="ExampleParser",\n        # define your fields in order\n        default=[\n            # give each field a name, some standard types are defined for you.\n            ident,\n            count,\n            data_array,\n        ],\n    )\n\n    # Some example data bytes to parse\n    data = b"\\x01\\x00\\x01\\x80"\n    print(f"input bytes:\\t{data!r}\\n")\n    print(f"input hex:\\t{hex(data)}\\n")\n\n    # Parse the bytes\n    exampleParser.parse(data=data)\n    # Print the parsed data to see what we got\n    print(f"parsed:\\t{exampleParser}")\n    print(f"hex:\\t{hex(exampleParser)}\\n")\n\n    # Make a new frame from known data to send somewhere (like a socket)\n    exampleParser["id"].value = 3\n    exampleParser["count"].value = 2\n    exampleParser["data"].value = [\n        127,\n        UInt8Field(name="new data", default=15),\n    ]\n\n    print(f"parsed:\\t{exampleParser}")\n    print(f"hex:\\t{hex(exampleParser)}\\n")\n\n    # You can access parsed elements of a ParseDict by name.\n    idField = exampleParser[ident.name]\n    dataCountField = exampleParser[count.name]\n    dataField = cast(ParseFieldList, exampleParser[data_array.name])\n\n    # The ArrayField is a list type, so children are accessed by numeric index.\n    for child in exampleParser.values():\n        print(f"{child.name}:\\t{child.value}\\t\\t{child.bits_str}")\n    ```\n\n- Output\n\n    ```bash\n    input bytes:    b\'\\x01\\x00\\x01\\x80\'\n\n    input hex:      01 00 01 80\n\n    parsed: ExampleParser: {id: 1, count: 1 data items, data: [#0: 80(hex)]}\n    hex:    01 00 01 80\n\n    parsed: ExampleParser: {id: 3, count: 2 data items, data: [#0: 7F(hex), #1: 0F(hex)]}\n    hex:    03 00 02 7F 0F\n\n    id:     3               00000011:<b\n    count:  2               0000000000000010:<b\n    data:   [<UInt8Field> #0: 7F(hex), <UInt8Field> #1: 0F(hex)]            0111111100001111:<b\n        ```\n',
    'author': 'joeferg425',
    'author_email': None,
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
