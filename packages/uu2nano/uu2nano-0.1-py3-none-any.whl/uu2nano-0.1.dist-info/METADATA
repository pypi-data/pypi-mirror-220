Metadata-Version: 2.1
Name: uu2nano
Version: 0.1
Summary: Conversion tool from UUID to nanoid and vice versa
Author-email: Aleksandr Karpinskii <homm86@gmail.com>
Keywords: uuid,nanoid
Requires-Python: >=3.7
Description-Content-Type: text/markdown

# uu2nano

Simple tool for converting well-known [UUID](https://datatracker.ietf.org/doc/html/rfc4122)
format (36 chars) to [nanoid](https://pypi.org/project/nanoid/) format (21 chars).


## Details of conversion

UUID is basically a 128-bit number. Some of those bits contain metadata including
the version, on which the contents of the remaining bits depend.
For example, for for UUIDv4 all 122 unspecified bits should contain random extropy.
But more interesting that regardless of version, 2 bits in each UUID are fixed.
That is why any UUID of any version could be encoded as 126 bits.

This number is encoded in hex format (4 bit per symbol) and 4 hyphens are added
as separators, which leads to 128/4 + 4 = 36 characters in string representation.

For example: 492b6acb-05c7-4914-b139-253070a085e9

Nanoid is encoded using 64 URL-safe symbols (A-Za-z0-9_-) which makes possible
to store 6 bits of information in one symbol. To store 126 UUID bits, only 
126 / 6 = 21 characters are used in string representation.

For example: Dl6CK-h7T2hfg5lKMEHgg


## Usage

Convert one to another:

```python
import uuid
from uu2nano import fix_uuid, nanoid_to_uuid, uuid_to_nanoid

uu = uuid.uuid4()
nano = uuid_to_nanoid(uu)
assert uu == nanoid_to_uuid(nano)
```

If you receive UUIDs from an untrusted place, there is a chance that eventually
two reserved fixed bits could be wrong. In this case `uuid_to_nanoid` will fail:

```python

@app.post
def find_book(uu: uuid.UUID):
    nano = uuid_to_nanoid(uu)

AssertionError: Wrong mark bits. Use fix_uuid() for true random input
```

In this case you can use `fix_uuid` function to make a valid UUID.
Please note that in this case UUID will be changed, so you have to save
new alias somewhere.
