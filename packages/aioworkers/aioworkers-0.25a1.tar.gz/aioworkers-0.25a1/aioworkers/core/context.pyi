from ..utils import import_name as import_name
from .base import AbstractEntity as AbstractEntity, NameLogger as NameLogger
from .config import ValueExtractor as ValueExtractor
from _typeshed import Incomplete
from collections.abc import Generator
from typing import Callable, FrozenSet, Iterable, Iterator, List, MutableMapping, Optional, Sequence, Set, Tuple, Type, TypeVar, Union

T = TypeVar('T')
TSeq = Union[Sequence, Set, FrozenSet]
DOT: str

class Octopus(MutableMapping):
    def items(self): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def extended_repr(self, *, indent: int = ..., header: bool = ...): ...
    def find_iter(self, cls: Type[T], *, exclude: Optional[Set[int]] = ...) -> Iterable[Tuple[str, T]]: ...

class Signal:
    LOG_RUN: str
    LOG_END: str
    LOG_EXC: str
    def __init__(self, context: Context, name: Optional[str] = ...) -> None: ...
    def append(self, signal: Callable, groups: TSeq = ...): ...
    def send(self, group_resolver: GroupResolver, *, coroutine: bool = ..., timeout: Optional[float] = ...): ...

class GroupResolver:
    def __init__(self, include: Incomplete | None = ..., exclude: Incomplete | None = ..., all_groups: bool = ..., default: bool = ...) -> None: ...
    def match(self, groups): ...

class ContextProcessor:
    key: str
    context: Incomplete
    path: Incomplete
    value: Incomplete
    def __init__(self, context: Context, path: str, value: ValueExtractor) -> None: ...
    @classmethod
    def match(cls, context: Context, path: str, value: ValueExtractor): ...
    async def process(self) -> None: ...

class LoggingContextProcessor(ContextProcessor):
    key: str
    process: Incomplete
    @classmethod
    def match(cls, context, path, value): ...
    def configure(self, value) -> None: ...

class GroupsContextProcessor(ContextProcessor):
    key: str
    process: Incomplete
    @classmethod
    def match(cls, context, path, value): ...

class EntityContextProcessor(ContextProcessor):
    key: str
    entity: Incomplete
    def __init__(self, context: Context, path: str, value: ValueExtractor) -> None: ...
    @classmethod
    def match(cls, context: Context, path: str, value: ValueExtractor) -> Optional[ContextProcessor]: ...
    async def process(self) -> None: ...

class InstanceEntityContextProcessor(EntityContextProcessor):
    key: str
    entity: Incomplete
    def __init__(self, context: Context, path: str, value: ValueExtractor) -> None: ...
    @classmethod
    def match(cls, context: Context, path: str, value: ValueExtractor) -> Optional[ContextProcessor]: ...
    async def process(self) -> None: ...

class FuncContextProcessor(ContextProcessor):
    key: str
    process: Incomplete
    def __init__(self, context: Context, path: str, value: ValueExtractor) -> None: ...
    @classmethod
    def match(cls, context: Context, path: str, value: ValueExtractor) -> Optional[ContextProcessor]: ...

class RootContextProcessor(ContextProcessor):
    processors: Incomplete
    on_ready: Incomplete
    def __init__(self, context, path: Incomplete | None = ..., value: Incomplete | None = ...) -> None: ...
    def __iter__(self) -> Iterator[ContextProcessor]: ...
    def processing(self, config, path: Incomplete | None = ...) -> None: ...
    value: Incomplete
    def build(self, config) -> None: ...
    async def process(self, config: Incomplete | None = ...) -> None: ...

class Context(AbstractEntity, Octopus):
    logger: Incomplete
    processors: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def set_group_resolver(self, gr) -> None: ...
    def set_config(self, config) -> None: ...
    def set_loop(self, loop) -> None: ...
    def processes(self) -> Generator[None, None, None]: ...
    @property
    def on_connect(self): ...
    @property
    def on_start(self): ...
    @property
    def on_stop(self): ...
    @property
    def on_disconnect(self): ...
    @property
    def on_cleanup(self): ...
    async def init(self) -> None: ...
    async def wait_all(self, coros, raises: bool = ...): ...
    async def connect(self, timeout: Optional[float] = ...): ...
    async def start(self) -> None: ...
    async def stop(self) -> None: ...
    async def disconnect(self) -> None: ...
    def run_forever(self) -> None: ...
    def __dir__(self) -> List[str]: ...
    def __getitem__(self, item): ...
    def __setitem__(self, key, value) -> None: ...
    def __setattr__(self, key, value) -> None: ...
    def __getattr__(self, item): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def get_object(self, path): ...
