# This file was generated by mettle.genes.db.GenPy3 [ver 2.2] on Thu Jul 20 09:12:34 2023
#

import datetime
import uuid
import time
import dataclasses
import typing
import mettle.io
import mettle.db

@dataclasses.dataclass(slots=True)
class tUla(mettle.io.ISerializable):

    site_id: int = dataclasses.field(default=0, compare=False)
    site_code: str = dataclasses.field(default='', compare=False)
    tm_stamp: typing.Optional[datetime.datetime] = dataclasses.field(default=None, compare=False)
    usr_id: str = dataclasses.field(default='', compare=False)
    err_code: int = dataclasses.field(default=0, compare=False)
    state: str = dataclasses.field(default='', compare=False)
    action: str = dataclasses.field(default='', compare=False)
    auth_type: str = dataclasses.field(default='', compare=False)
    auth_ip: str = dataclasses.field(default='', compare=False)
    auth_geo: str = dataclasses.field(default='', compare=False)

    def clear(self):
        """
        Clears all member variables for this database record.
        """
        self.site_id = 0
        self.site_code = ''
        self.tm_stamp = None
        self.usr_id = ''
        self.err_code = 0
        self.state = ''
        self.action = ''
        self.auth_type = ''
        self.auth_ip = ''
        self.auth_geo = ''

    def _name(self) -> str:
        """
        Name of the record.

        :return: The name.
        """
        return 'tUla'

    def _serialize(self, _w: mettle.io.IWriter, _oname: str = None):
        """
        Serialize record to a stream.

        :param _w:
        :param _oname:
        """
        if _oname == None:
            _oname = self._name()

        _w.write_start(_oname)
        _w.write_int32("site_id", self.site_id)
        _w.write_string("site_code", self.site_code)
        _w.write_datetime("tm_stamp", self.tm_stamp)
        _w.write_string("usr_id", self.usr_id)
        _w.write_int32("err_code", self.err_code)
        _w.write_char("state", self.state)
        _w.write_char("action", self.action)
        _w.write_char("auth_type", self.auth_type)
        _w.write_string("auth_ip", self.auth_ip)
        _w.write_string("auth_geo", self.auth_geo)
        _w.write_end(_oname)

    def _deserialize(self, _r: mettle.io.IReader, _oname: str = None):
        """
        Deserialize record from a stream.

        :param _r:
        :param _oname:
        """
        if _oname == None:
            _oname = self._name()

        _r.read_start(_oname)
        self.site_id = _r.read_int32("site_id")
        self.site_code = _r.read_string("site_code")
        self.tm_stamp = _r.read_datetime("tm_stamp")
        self.usr_id = _r.read_string("usr_id")
        self.err_code = _r.read_int32("err_code")
        self.state = _r.read_char("state")
        self.action = _r.read_char("action")
        self.auth_type = _r.read_char("auth_type")
        self.auth_ip = _r.read_string("auth_ip")
        self.auth_geo = _r.read_string("auth_geo")
        _r.read_end(_oname)

    def _copy_from(self, rec: "tUla"):
        """
        Copies the column from the rec into this record.

        :param rec: The source record.
        """
        self.site_id = rec.site_id
        self.site_code = rec.site_code
        self.tm_stamp = rec.tm_stamp
        self.usr_id = rec.usr_id
        self.err_code = rec.err_code
        self.state = rec.state
        self.action = rec.action
        self.auth_type = rec.auth_type
        self.auth_ip = rec.auth_ip
        self.auth_geo = rec.auth_geo

    @staticmethod
    def _cache_davs(dvc=None, for_ins: bool = False, key_only: bool = False):
        """
        Cache the DAV into the dav cache (or create one) and return it.

        :param dvc: (mettle.lib.DavCache), target cache, if None a new one is created and returned.
        :param for_ins: Davs for insert.
        :param key_only: Davs by key only, ie for delete/selectone.
        """
        if dvc is None:
            dvc = mettle.lib.DavCache()

        dvc.add_targ("site_id", mettle.lib.Dav(mettle.lib.Dav.eDavType.NotNull))
        dvc.add_targ("site_code", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 32))
        dvc.add_targ("tm_stamp", mettle.lib.Dav(mettle.lib.Dav.eDavType.NotNull))
        dvc.add_targ("usr_id", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 128))
        dvc.add_targ("err_code", mettle.lib.Dav(mettle.lib.Dav.eDavType.NotNull))
        dvc.add_targ("state", mettle.lib.Dav(mettle.lib.Dav.eDavType.Min, 1))
        dvc.add_targ("state", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 1))
        dvc.add_targ("state", mettle.lib.Dav(mettle.lib.Dav.eDavType.NotNull))
        dvc.add_targ("state", mettle.lib.Dav(mettle.lib.Dav.eDavType.In, ['S','P','K','G','N','M','O','U']))
        dvc.add_targ("action", mettle.lib.Dav(mettle.lib.Dav.eDavType.Min, 1))
        dvc.add_targ("action", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 1))
        dvc.add_targ("action", mettle.lib.Dav(mettle.lib.Dav.eDavType.NotNull))
        dvc.add_targ("action", mettle.lib.Dav(mettle.lib.Dav.eDavType.In, ['L','O','R','E','C']))
        dvc.add_targ("auth_type", mettle.lib.Dav(mettle.lib.Dav.eDavType.Min, 1))
        dvc.add_targ("auth_type", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 1))
        dvc.add_targ("auth_type", mettle.lib.Dav(mettle.lib.Dav.eDavType.NotNull))
        dvc.add_targ("auth_ip", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 32))
        dvc.add_targ("auth_geo", mettle.lib.Dav(mettle.lib.Dav.eDavType.Max, 64))

        return dvc

    def _get_davs(self, dvc=None, for_ins: bool = False, key_only: bool = False):
        tUla._cache_davs(dvc, for_ins, key_only)

    def _write_key(self, _key: None):
        """
        Write primary key columns to _key.

        :param _key:
        """

    def _read_key(self, _key: None):
        """
        Read the primary key columns from _key.

        :param _key:
        """

    class State_Couplet(dict):
        key_success = "S"
        key_password_invalid = "P"
        key_ssh_invalid = "K"
        key_geo_location_changed = "G"
        key_auth_null = "N"
        key_max_attemps = "M"
        key_otp_invalid = "O"
        key_unexpected_error = "U"

        value_success = "Success"
        value_password_invalid = "Password Invalid"
        value_ssh_invalid = "SSH Invalid"
        value_geo_location_changed = "Geo Location Changed"
        value_auth_null = "Auth Null"
        value_max_attemps = "Max Attemps"
        value_otp_invalid = "OTP Invalid"
        value_unexpected_error = "Unexpected Error"

        def __init__(self):
            self[self.key_success] = self.value_success
            self[self.key_password_invalid] = self.value_password_invalid
            self[self.key_ssh_invalid] = self.value_ssh_invalid
            self[self.key_geo_location_changed] = self.value_geo_location_changed
            self[self.key_auth_null] = self.value_auth_null
            self[self.key_max_attemps] = self.value_max_attemps
            self[self.key_otp_invalid] = self.value_otp_invalid
            self[self.key_unexpected_error] = self.value_unexpected_error

        @staticmethod
        def get_value(key):
            if key == tUla.State_Couplet.key_success:
                return tUla.State_Couplet.value_success

            if key == tUla.State_Couplet.key_password_invalid:
                return tUla.State_Couplet.value_password_invalid

            if key == tUla.State_Couplet.key_ssh_invalid:
                return tUla.State_Couplet.value_ssh_invalid

            if key == tUla.State_Couplet.key_geo_location_changed:
                return tUla.State_Couplet.value_geo_location_changed

            if key == tUla.State_Couplet.key_auth_null:
                return tUla.State_Couplet.value_auth_null

            if key == tUla.State_Couplet.key_max_attemps:
                return tUla.State_Couplet.value_max_attemps

            if key == tUla.State_Couplet.key_otp_invalid:
                return tUla.State_Couplet.value_otp_invalid

            if key == tUla.State_Couplet.key_unexpected_error:
                return tUla.State_Couplet.value_unexpected_error

            return ""

    class Action_Couplet(dict):
        key_login = "L"
        key_logout = "O"
        key_reset_auth = "R"
        key_elevated_access_token = "E"
        key_change_auth = "C"

        value_login = "Login"
        value_logout = "Logout"
        value_reset_auth = "Reset Auth"
        value_elevated_access_token = "Elevated Access Token"
        value_change_auth = "Change Auth"

        def __init__(self):
            self[self.key_login] = self.value_login
            self[self.key_logout] = self.value_logout
            self[self.key_reset_auth] = self.value_reset_auth
            self[self.key_elevated_access_token] = self.value_elevated_access_token
            self[self.key_change_auth] = self.value_change_auth

        @staticmethod
        def get_value(key):
            if key == tUla.Action_Couplet.key_login:
                return tUla.Action_Couplet.value_login

            if key == tUla.Action_Couplet.key_logout:
                return tUla.Action_Couplet.value_logout

            if key == tUla.Action_Couplet.key_reset_auth:
                return tUla.Action_Couplet.value_reset_auth

            if key == tUla.Action_Couplet.key_elevated_access_token:
                return tUla.Action_Couplet.value_elevated_access_token

            if key == tUla.Action_Couplet.key_change_auth:
                return tUla.Action_Couplet.value_change_auth

            return ""


    class List(list, mettle.io.ISerializable):
        """
        List Class
        """

        def _name(self) -> str:
            """
            Name of the list.

            :return: The name
            """
            return 'tUla.List'

        def _serialize(self, _w: mettle.io.IWriter, _oname: str = None):
            """
            Serialize the list to a stream.

            :param _w:
            :param _oname:
            """
            if _oname == None:
                _oname = self._name()

            _w.write_start_list(_oname, len(self))

            for _rec in self:
                _rec._serialize(_w)

            _w.write_end(_oname)

        def _deserialize(self, _r: mettle.io.IReader, _oname: str = None):
            """
            Deserialize the list from a stream.

            :param _r:
            :param _oname:
            """
            if _oname == None:
                _oname = self._name()

            _cnt = _r.read_start_list(_oname)

            while _cnt >= 1:
                _rec  = tUla()
                _cnt -= 1
                _rec._deserialize(_r)
                self.append(_rec)

            _r.read_end(_oname)

        def _get_davs(self, dvc=None, for_ins: bool = False, key_only: bool = False):
            return tUla._cache_davs(dvc, for_ins, key_only)

